- name: Deploy EMQX cluster with host networking
  hosts: node
  become: true
  
  vars_files:
    - secret.yml
    - variables.yml

  pre_tasks:

    - name: Set boolean if EMQX version is newer or equal to 5.9
      set_fact:
        is_new_version: "{{ emqx_version is version('5.9', '>=') }}"

    - name: Determine if clustering is needed
      set_fact:
        is_cluster: "{{ groups['node'] | length > 1 }}"

    - name: Fail if emqx_local_licence_file variable is not defined
      fail:
        msg: "For clustering, EMQX version {{ emqx_version }} requires a licence file, but the variable 'emqx_local_licence_file' is not defined."
      when:
        - is_new_version
        - is_cluster
        - emqx_local_licence_file is not defined

    - name: Check if local licence file exists (on control machine)
      stat:
        path: "{{ emqx_local_licence_file }}"
      register: licence_file_status
      delegate_to: localhost
      run_once: true
      when:
        - is_cluster     
        - is_new_version
        - emqx_local_licence_file is defined

    - name: Fail if local licence file is missing and version is new
      fail:
        msg: "For clustering, EMQX version {{ emqx_version }} requires a licence file, but {{ emqx_local_licence_file }} was not found."
      when:
        - is_cluster
        - is_new_version
        - emqx_local_licence_file is defined
        - not licence_file_status.stat.exists
        
    - name: Read license file as plain text
      set_fact:
        emqx_license_key: "{{ lookup('file', emqx_local_licence_file) | trim }}"
      when:
        - is_cluster
        - is_new_version

    - name: Generate shared Erlang cookie (once)
      run_once: true
      delegate_to: localhost
      vars:
        cookie: "{{ lookup('password', '/dev/null', length=64, chars='ascii_letters,digits') }}"
      set_fact:
        emqx_erlang_cookie: "{{ cookie }}"

    - name: Build all_nodes list from inventory
      set_fact:
        all_nodes: "{{ all_nodes | default([]) + ['emqx@' + item] }}"
      loop: "{{ groups['node'] }}"

    - name: Build etc_hosts from DNS resolution
      set_fact:
        extra_hosts: "{{ extra_hosts | default({}) | combine(host_entry) }}"
      vars:
        ip: "{{ lookup('community.general.dig', item) }}"
        host_entry: "{{ { item: ip } if ip != 'NXDOMAIN' else {} }}"
      loop: "{{ groups['node'] }}"
        
  tasks:

    - name: Set EMQX_NODE_NAME
      set_fact:
        emqx_node_name: "emqx@{{ inventory_hostname }}"

    - name: Set cluster seeds excluding self
      set_fact:
        cluster_seeds: "{{ all_nodes | difference([emqx_node_name]) }}"

    - name: Install Docker (Debian/Ubuntu)
      apt:
        name: docker.io
        state: present
      when: ansible_os_family == "Debian"

    - name: Start Docker service
      service:
        name: docker
        state: started
        enabled: true

    - name: Pull EMQX image
      docker_image:
        name: "{{ emqx_image }}"
        tag: "{{ emqx_version }}"
        source: pull

    - name: Check if EMQX container exists
      docker_container_info:
        name: "{{ emqx_container_name }}"
      register: emqx_info
      ignore_errors: true

    - name: Stop EMQX container (if it exists)
      docker_container:
        name: "{{ emqx_container_name }}"
        state: stopped
      when:
        - emqx_info.container is defined
        - emqx_info.container is not none
        - emqx_info.container.State is defined
        - emqx_info.container.State.Status == "running"
        
    - name: Remove EMQX container if exists
      docker_container:
        name: "{{ emqx_container_name }}"
        state: absent
      ignore_errors: true
      when: emqx_info.container is defined

    - name: Create base EMQX env dictionary
      set_fact:
        emqx_env_base:
          EMQX_DASHBOARD__DEFAULT_USERNAME: "{{ emqx_admin_user }}"
          EMQX_DASHBOARD__DEFAULT_PASSWORD: "{{ emqx_admin_password }}"
          EMQX_NODE_NAME: "{{ emqx_node_name }}"
          EMQX_AUTHENTICATION__1__BACKEND: "built_in_database"
          EMQX_AUTHENTICATION__1__MECHANISM: "password_based"
          EMQX_AUTHENTICATION__1__PASSWORD_HASH_ALGORITHM__NAME: "sha256"
          EMQX_AUTHENTICATION__1__PASSWORD_HASH_ALGORITHM__SALT_POSITION: "prefix"
          EMQX_AUTHENTICATION__1__USER_ID_TYPE: "username"

    - name: Add cluster config if clustering is enabled
      set_fact:
        emqx_env_with_cluster: >-
          {{
            emqx_env_base
            | combine(
                is_cluster | bool | ternary(
                  {
                    "EMQX_CLUSTER__DISCOVERY_STRATEGY": "static",
                    "EMQX_CLUSTER__STATIC__SEEDS": cluster_seeds | join(',')
                  },
                  {}
                )
              )
          }}

    - name: Add license key only if clustering and new version
      set_fact:
        emqx_env: >-
          {{
            emqx_env_with_cluster | default(emqx_env_base)
            | combine(
                (is_cluster and is_new_version) | bool | ternary(
                  {"EMQX_LICENSE__KEY": emqx_license_key},
                  {}
                )
              )
          }}

    - name: Start EMQX container with host networking
      become: true
      become_user: gbnode
      become_method: sudo      
      docker_container:
        name: "{{ emqx_container_name }}"
        image: "{{ emqx_image }}:{{ emqx_version }}"
        hostname: "{{ inventory_hostname }}"
        state: started
        restart_policy: always
        network_mode: host
        env: "{{ emqx_env }}"
        etc_hosts: "{{ extra_hosts }}"
        healthcheck:
          test: ["CMD", "/opt/emqx/bin/emqx", "ctl", "status"]
          interval: 5s
          timeout: 25s
          retries: 5

    - name: Wait for EMQX to be ready
      uri:
        url: "http://localhost:18083/api/v5/status"
        status_code: 200
      register: emqx_status
      until: emqx_status.status == 200
      retries: 20
      delay: 5          

    - name: Pick a random host from the group
      set_fact:
        delegate_host: "{{ groups['node'] | random }}"
      run_once: true

    - name: Run only on the random host
      delegate_to: "{{ delegate_host }}"
      run_once: true
      block: 
        - name: Log in to EMQX and get token
          uri:
            url: "{{ emqx_api_url }}/login"
            method: POST
            body_format: json
            headers:
              Content-Type: "application/json"
            body:
              username: "{{ emqx_admin_user }}"
              password: "{{ emqx_admin_password }}"
            return_content: true
          register: login_response
          until: login_response.status == 200
          retries: 10
          delay: 5       

        - name: Extract token from login response
          set_fact:
            emqx_token: "{{ login_response.json.token }}"

        - name: Check if EMQX user exists
          uri:
            url: "{{ emqx_api_url }}/authentication/password_based%3Abuilt_in_database/users/{{ item.user_id }}"
            method: GET
            headers:
              Authorization: "Bearer {{ emqx_token }}"
            status_code: [200, 404]
            return_content: yes
          register: user_check
          until: user_check.status == 200 or user_check.status == 404
          retries: 10
          delay: 5     
          loop: "{{ emqx_user_list }}"
          loop_control:
            label: "{{ item.user_id }}"           

        - name: Delete EMQX user if exists
          uri:
            url: "{{ emqx_api_url }}/authentication/password_based%3Abuilt_in_database/users/{{ item.0.user_id }}"
            method: DELETE
            headers:
              Authorization: "Bearer {{ emqx_token }}"
            status_code: [200, 204]
          loop: "{{ emqx_user_list | zip(user_check.results) }}"
          loop_control:
            label: "{{ item.0.user_id }}"
          when: item.1.status == 200

        - name: Recreate EMQX user
          uri:
            url: "{{ emqx_api_url }}/authentication/password_based%3Abuilt_in_database/users"
            method: POST
            headers:
              Authorization: "Bearer {{ emqx_token }}"
              Content-Type: "application/json"
            body_format: json
            body:
              user_id: "{{ item.user_id }}"
              password: "{{ item.password }}"
              is_superuser: "{{ item.is_superuser }}"
            status_code: [200, 201]
          register: emqx_response
          until: emqx_response.status == 200 or emqx_response.status == 201
          retries: 10
          delay: 5            
          loop: "{{ emqx_user_list }}"
          loop_control:
            label: "{{ item.user_id }}" 

        - name: Check existing EMQX authorization sources
          uri:
            url: "{{ emqx_api_url }}/authorization/sources"
            method: GET
            headers:
              Authorization: "Bearer {{ emqx_token }}"
              Accept: "*/*"
            return_content: true
            status_code: 200
          register: auth_sources

        - name: Add EMQX authorization source (built-in database) if missing
          uri:
            url: "{{ emqx_api_url }}/authorization/sources"
            method: POST
            headers:
              Authorization: "Bearer {{ emqx_token }}"
              Accept: "*/*"
              Content-Type: "application/json"
            body:
              enable: true
              max_rules: 100
              type: built_in_database
            body_format: json
            return_content: true
            status_code: 204
          when: >
            auth_sources.json.sources is defined and
            auth_sources.json.sources | selectattr('type', 'equalto', 'built_in_database') | list | length == 0

        - name: Set EMQX authorization rules for user 'everyone'
          uri:
            url: "{{ emqx_api_url }}/authorization/sources/built_in_database/rules/users/everyone"
            method: PUT
            headers:
              Authorization: "Bearer {{ emqx_token }}"
              Content-Type: "application/json"
            body:
              username: "everyone"
              rules:
                - action: "subscribe"
                  permission: "allow"
                  topic: "cache/a/wis2/#"
                  qos: [0, 1]
                - action: "subscribe"
                  permission: "allow"
                  topic: "origin/a/wis2/#"
                  qos: [0, 1]
                - action: "subscribe"
                  permission: "allow"
                  topic: "monitor/a/wis2/#"
                  qos: [0, 1]
                - action: "all"
                  permission: "deny"
                  topic: "#"
            body_format: json
            status_code: 204

      